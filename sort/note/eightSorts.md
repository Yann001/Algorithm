# 八种排序算法

>根据几篇博客整理
>博客地址：
>- http://blog.csdn.net/u010850027/article/details/49362279
>- http://blog.csdn.net/han_xiaoyang/article/details/12163251

**目录**

[TOC]

排序是数据处理中一种很重要也很常用的运算，一般情况下，排序操作在数据处理过程中要花费许多时间，为了提高计算机的运行效率，我们提出并不断改进各种各样的排序算法，这些算法也从不同角度展示了算法设计的重要原则和技巧。排序就是对一组杂乱无章的数据进行各种各样的排序，使其从无序的数据变成有序的数据，排序的目的就是为了方便查找，分内部排序和外部排序。如下图所示：

![](http://i4.buimg.com/567571/13b37d3957929ed8.png)

总的来说，在排序中，有三种基本的排序，选择排序、插入排序和交换排序，其余的排序都是在这三种基本的排序上演化或者是优化而来的，首先我们来看选择排序。

## 选择排序
选择排序包括两种，分别是直接选择排序和堆排序。
### 直接选择排序
选择排序的基本思想是每一次在n-i+1（i=1,2,3，...，n-1）个记录中选取键值最小的记录作为有序序列的第i个记录，首先我们来看选择排序中的第一种排序---直接选择排序。直接选择排序的基本思想是，在第i次选择操作中，通过n-i次键值间比较，从n-i+1个记录中选出键值最小的记录，并和第i（1小于等于1小于等于n-1）个记录交换，说了基本思想之后，赶脚还是稀里糊涂的，我们来看一下直接选择排序具体是如何排序的，如下图所示：

<iframe width=400px height=380px src="http://i1.piimg.com/567571/585b3ca03843d93c.gif" ></iframe>

如上所示的一组序列为8、5、2、6、9、3、1、4、0、7，首先我们在这个里面选取一个最小的数当然最大的也可以，具体根据要求来进行选择，我们以从小到大的顺序进行排列，首先，我们选取一个最小的数字0,0和8进行交互位置，经过第一次选择之后，序列的顺序变成0、5、2、6、9、3、1、4、8、7，接着进行第二次选择，再选择一个最小的数字1,1和5交互位置，依次类推，直到该序列是有序序列为止。
实现代码如下：
```js
var directSelect = function(arr) {
	var len = arr.length;
	for (var i = 0; i < len; i++) {
		for(var j = i; j < len; j++) {
			if(arr[j] < arr[i]) {
				arr[i] = [arr[j], arr[j] = arr[i]][0];
			}
		}
	}
	return arr;
}
```

#### 堆排序

**1. 算法简介**

&emsp;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

**2. 算法描述**

1. 什么是堆？
我们这里提到的堆一般都指的是二叉堆，它满足二个特性：
	- 父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
	- 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

  如下为一个最小堆(父结点的键值总是小于任何一个子节点的键值)

  ![](http://i1.piimg.com/567571/f98ab344b43df13c.png)

2. 什么是堆调整(Heap Adjust)？
这是为了保持堆的特性而做的一个操作。对某一个节点为根的子树做堆调整，其实就是将该根节点进行“下沉”操作(具体是通过和子节点交换完成的)，一直下沉到合适的位置，使得刚才的子树满足堆的性质。
例如对最大堆的堆调整我们会这么做：
  1. 在对应的数组元素A[i], 左孩子A[LEFT(i)], 和右孩子A[RIGHT(i)]中找到最大的那一个，将其下标存储在largest中。
  2. 如果A[i]已经就是最大的元素，则程序直接结束。
  3. 否则，i的某个子结点为最大的元素，将A[largest]与A[i]交换。
  4. 再从交换的子节点开始，重复1,2,3步，直至叶子节点，算完成一次堆调整。

  这里需要提一下的是，一般做一次堆调整的时间复杂度为log(n)。
  如下为我们对4为根节点的子树做一次堆调整的示意图，可帮我们理解。

  ![](http://i1.piimg.com/567571/00581c653be44f49.jpg)

3. 如何建堆
建堆是一个通过不断的堆调整，使得整个二叉树中的数满足堆性质的操作。在数组中的话，我们一般从下标为n/2的数开始做堆调整，一直到下标为0的数(因为下标大于n/2的数都是叶子节点，其子树已经满足堆的性质了)。下图为其一个图示：
![](http://i2.muimg.com/567571/55ee68dfdd4cd8f6.png)
![](http://i4.buimg.com/567571/8273ed23238c5117.png)
很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即20，60， 65， 4， 49都分别是一个合法的堆。只要从A[4]=50开始向下调整就可以了。然后再取A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9分别作一次向下调整操作就可以了。

4. 如何进行堆排序
堆排序是在上述3中对数组建堆的操作之后完成的。
数组储存成堆的形式之后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n-2]交换，再对A[0…n-3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。
如下图所示：
![](http://i4.buimg.com/567571/339b1129138372a4.png)
![](http://i4.buimg.com/567571/208c8d924a1b5cfb.png)
![](http://i2.muimg.com/567571/33434f88dae8c8a7.png)
**
最差时间复杂度:
O(n log n)
最优时间复杂度:
O(n log n)
平均时间复杂度:
O(n log n)
最差空间复杂度:
O(n)
**
实现代码如下：
```js
/*返回父节点*/
int parent(int i)
{
    return (int)floor((i - 1) / 2);
}
```




















由上面的直接选择排序分析，我们知道，在n个键值中选出最小值，至少进行n-1次比较，然而继续在剩余的n-1个键值中选择出第二个小的值是否一定要进行n-2次比较呢？如果能利用钱n-1次比较所得信息，是否可以减少以后各次选中的次数比较呢？基本这个，我们来看堆排序，堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] >= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。我们来看堆排序到底是怎么排的呢？下面我们以小堆为例，如下图所示：


<iframe width=400px height=280px src="http://i2.muimg.com/567571/e2faccf2df0c7890.gif" ></iframe>

如上图所示的序列是6、5、3、1、8、7、2、4，我们首先将其构建成一个堆，通过构建我们发现这个时候的序列为8、6、7、4、5、3、2、1，接着，我们1和8进行比较，发现1小于8，所以交互位置，刨去8，这个时候的序列为1、6、7、4、5、3、2，发现7比1大，交互位置，1比3小，交互位置，构成的是一个大顶堆了，这个时候，只需要7跟二叉树的最后一个节点进行比较即可，刨去7，依次类推。











































